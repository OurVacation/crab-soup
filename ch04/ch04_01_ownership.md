# 🦀 Chapter 03_02. 데이터 타입

> **작성자:** taewonki

> **학습 날짜:** 2026.02.13

> **주요 키워드:** #소유권 #Move #Copy

---

## 1. 🥘 핵심 재료 (Key Concepts) : 러스트의 첫 난관 "소유권"

**배경 지식 :** 스택영역과 힙 영역의 메모리 할당 구분

### (1) 소유권 (OwnerShip)

- **정의 :** 러스트 프로그램에서 메모리를 지배하는 규칙

- **사용 이유:** 한 데이터에 여러 변수로 접근하는 것을 막기 위해 사용한다.

- **소유권 규칙**
	- Rust에서 각각의 값은 소유자가 정해져 있다.
	- 한 값의 소유자는 여러명 존재할 수 없다.
	- 소유자가 스코프 밖으로 벗어날 때, 값은 버려진다 (dropped)

- **특징**
1. 변수의 스코프
	다른 언어와 동일하다. `{}`를 벗어나면 스코프를 벗어나게 된다. 소유권은 기본적으로 이 스코프 내에서만 유효하다. 이 말은 즉, 러스트에서 어떤 변수가 스코프를 벗어나게 되면, 자동으로 해당 변수를 저장하던 메모리가 해제된다는 뜻이다.

2. 변수와 데이터 간 상호작용 방식
	소유권은 결국 변수와, 변수가 저장한 데이터와의 상호작용 방식이다.
	이 상호작용이 데이터 타입에 따라 다르게 나타난다. 이를 알아보고자 한다.

	1. Move : 소유권을 넘겨준다.
		이것은 복사가 아니라 이동이다. Rust에서는 C/C++ 에서의 얕은 복사를 컴파일 단계에서부터 허용하지 않는다.
		```rust
		fn main() {
			let s1 = String::from("hello");
			let s2 = s1;
			println!("s1은 {}", s1);
		}
		```
		위 코드는 컴파일 오류가 발생하는데 이유는 왜일까?

		C의 경우에는 위 같은 코드를 작성하면 s1과 s2가 같은 메모리 영역을 가리키게 되고 s1의 값을 s2도 수정할수 있고 뭐 그렇게 된다. (포인터 값이라면)

		근데 러스트에서는 소유권이라는 개념때문에 그럴 수가 없다. 위 메인은 규칙2번을 위배하고 있다.

		`let s2 = s1;` 을 한 순간 `String::from("hello")` 라는 값의 소유권이 `s1`에서 `s2`로 넘어가게 된 것이다. 따라서 위 값의 주인은 `s2` 이므로 s1의 값은 없다. 메모리를 가리키는 포인터가 아예 없어진거다.

	2. Clone : 복제 (깊은 복사)
		내용을 모두 복사해서 새 메모리 공간을 힙에 할당하고, 그 소유권은 새 변수로 감
		```rust
		fn main() {
			let s1 = String::from("hello");
			let s2 = s1.clone();
			println!("s1 = {}, s2 = {}", s1, s2);
		}
		```

	3. Copy : 예외 (스택 데이터 타입)
		다른 언어에서 원시타입, Primitive type 등으로 표시하는 단순한 타입들은 내부에 Copy Trait을 구현해 두었다. 이러한 타입들은 내부 값을 복제하는데 오버헤드가 별로 크지 않다.
		```rust
		fn main() {
			let x = 5; // x는 5
			let y = x; // y는 5
			// 둘 다 잘 된다!
			println!("x = {}, y = {}", x, y);
		}
		```
		이 예시는 컴파일 오류 없이 잘 된다.

		위에서 안된다고 하는데, 여긴 왜 될까? 해당 타입은 내부적으로 Copy가 발생하기 때문에 잘 돌아가는 모습이다.
---

## 2. 🍳 조리 과정 (Code & Analysis)

---

## 3. 🧂 깊은 맛 (Deep Dive)

- 나의 소유권 한 줄 정리 : 하나의 데이터에 접근 가능한 경로(변수)는 단 하나!

	이를 통해, 다른 언어에서 얕은 복사시 발생하는 댕글링 참조 문제 를 방지한다.
---

## 4. 🔥 실패와 해결 (Troubleshooting)

---

## 5. 😋 시식평 (Tasting Note)
- **난이도:** ⭐⭐⭐⭐☆
- **한줄평:** C/C++의 수동 해제도 아닌, java와 python의 GC도 아닌 새로운 메모리 관리 패러다임인 소유권에 대해 알아봤다. 이건 앞으로 러스트 코드를 작성함에 있어 우리의 발목을 아주 많이 잡겠지만, 이 불편함이 런타임 안정성의 비결이다.
