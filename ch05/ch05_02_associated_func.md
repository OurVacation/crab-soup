# 🦀 Chapter 05_02. 메서드와 연관 함수 (Method & Associated Functions)

> **작성자:** taewonki
> **학습 날짜:** 2026.02.13
> **주요 키워드:** #메서드 #impl #self #Self #연관함수

---

## 1. 🥘 핵심 재료 (Key Concepts)

### (1) 메서드 (Method)와 컨텍스트
- **정의:** 함수와 유사하게 매개변수와 반환값을 가지지만, 구조체(또는 열거형, 트레이트)의 컨텍스트(`impl` 블록) 내에 정의된다.
- **특징:** 첫 번째 매개변수는 항상 `self`이다. 이는 메서드가 호출되는 구조체 인스턴스를 의미한다.
- **컨텍스트:** `impl` 블록은 "이 함수들이 특정 타입의 이름 공간과 권한 안에 속해있다"는 것을 선언하는 논리적 영역이다.

### (2) self와 Self의 차이
- **self:** `self: &Self`의 축약형으로, 현재 인스턴스(값)를 의미한다. 메서드 내에서 인스턴스에 접근할 때 사용한다.
- **Self:** `impl` 블록의 대상이 되는 **구조체의 타입**을 의미한다. 대소문자 차이로 인스턴스와 타입을 구분한다.

### (3) 연관 함수 (Associated Functions)
- **정의:** `impl` 블록 내에 정의된 모든 함수를 연관 함수라고 부른다.
- **특징:** `self`를 첫 매개변수로 갖지 않는 함수도 작성 가능하며, 이는 동작하는 데 인스턴스가 필요 없는 경우(주로 생성자)에 사용된다. `구조체명::함수명`으로 호출한다.

---

## 2. 🍳 조리 과정 (Code & Analysis)

```rust
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    // 메서드: self를 가짐
    fn area(&self) -> u32 {
        self.width * self.height
    }

    // 연관 함수 (생성자): self가 없음
    fn square(size: u32) -> Self { // 반환 타입으로 Self 사용
        Self {
            width: size,
            height: size,
        }
    }
}

fn main() {
    // 연관 함수 호출 (:: 사용)
    let sq = Rectangle::square(3);
    // 메서드 호출 (. 사용)
    println!("Area: {}", sq.area());
}
```

### 🔍 코드 분석
- **Line 8:** `&self`는 `self: &Self`를 줄인 것이며, 인스턴스를 읽기만 하겠다는 의미다.
- **Line 13:** `Self` 키워드는 `Rectangle` 타입을 대신한다. 생성자 역할을 하는 연관 함수는 주로 새 인스턴스를 반환한다.

---

## 3. 🧂 깊은 맛 (Deep Dive)

### 1. 컨텍스트(Context)란 무엇인가?
- **정의:** "메서드가 구조체 컨텍스트 내에 정의된다"는 말은 해당 함수가 **특정 구조체 타입의 이름 공간(Namespace)과 권한 안에 속해 있다**는 뜻이다.
- **논리적 컨텍스트:**
    - **C언어:** 구조체(데이터)와 함수(동작)가 별개다. 따라서 `area(Rectangle r)`처럼 어떤 구조체용인지 함수 이름이나 매개변수로 명시해야 한다.
    - **Rust:** `impl Rectangle { ... }` 블록은 "이 안에서 벌어지는 일은 모두 `Rectangle`이라는 타입의 영역이다!"라고 선언하는 것이다. 즉, 데이터 설계도(struct)와 동작의 집합(impl)이 논리적으로 강력하게 결합된다.
- **문법적 컨텍스트 (self):**
    - 구조체 컨텍스트 안에 함수를 넣으면 "메서드"가 되며, 첫 번째 매개변수로 `self`를 사용할 수 있는 권한이 생긴다.

### 2. 메모리적 관점 (Memory Perspective)
- **가상 시나리오 (C언어):** 만약 C에서 구조체 내부에 동작을 포함시키기 위해 함수 포인터를 멤버로 넣는다면, 인스턴스를 만들 때마다 함수 포인터 크기만큼 메모리를 더 차지하게 된다.
- **Rust의 방식:**
    - **데이터:** 인스턴스마다 각각 스택/힙 메모리를 차지한다.
    - **메서드:** 프로그램의 **코드 영역(Code Segment)에 딱 1번만 저장**된다. 인스턴스가 100개든 1개든 메서드 코드 자체의 메모리 비용은 동일하다.

### 3. 요약: C언어 스타일 vs Rust (impl)

| 특징 | C언어 스타일 | Rust의 컨텍스트 (impl) |
| :--- | :--- | :--- |
| **결합도** | 함수와 구조체가 물리적으로 분리됨 | 함수가 구조체의 이름 공간 안에 묶임 |
| **호출** | `area(&my_rect)` | `my_rect.area()` (더 직관적) |
| **캡슐화** | private 구현이 어려움 | 컨텍스트 내부에서만 쓰는 비공개 메서드 가능 |
| **연관 함수** | 관련 함수를 찾기 위해 파일 전체를 뒤져야 함 | `impl` 블록만 보면 해당 타입의 모든 기능 파악 가능 |

---

## 4. 🔥 실패와 해결 (Troubleshooting)

### ❌ 이슈: 메서드 내에서의 소유권 (self)
- 메서드 정의 시 `self`, `&self`, `&mut self` 중 무엇을 써야 하는지 혼동될 수 있다.

### ✅ 해결 방법 (Solution)
- **&self (불변 참조):** 값을 읽기만 할 때 사용한다. (가장 일반적)
- **&mut self (가변 참조):** 인스턴스의 값을 변경해야 할 때 사용한다.
- **self (소유권 이동):** 인스턴스의 소유권을 메서드 안으로 가져와서 소비해버리거나, 다른 타입으로 변환 후 원본 사용을 막을 때 사용한다.

---

## 5. 😋 시식평 (Tasting Note)

- **난이도:** ⭐⭐☆☆☆
- **한줄평:** C에서는 함수랑 구조체가 따로 놀아서 불편했는데, impl로 묶이니까 훨씬 체계적이다.
