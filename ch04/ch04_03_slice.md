# 🦀 Chapter 04_03. 슬라이스 (Slice)

> **작성자:** taewonki
> **학습 날짜:** 2026.2.13
> **주요 키워드:** #슬라이스 #Slice #참조자 #String

---

## 1. 🥘 핵심 재료 (Key Concepts)

### (1) 슬라이스의 정의 및 구조
- **정의:** 슬라이스는 컬렉션(String, 배열 등)의 연속된 일부분을 가리키는 참조자이다.
- **특징:** 소유권이 없다. 즉, 데이터의 복사나 소유권의 이동 없이 원본 데이터의 일부를 "대여"하는 것이다.
- **구조:** 내부적으로 데이터의 시작 주소를 가리키는 **포인터**와 시작 지점부터 몇 개의 요소를 포함하는지를 나타내는 **길이** 정보를 저장한다.

### (2) 슬라이스 문법과 리터럴
- **문법:** `..n`은 처음부터 n-1까지의 범위를, `n..`은 n부터 마지막까지의 슬라이스를 의미한다.
- **문자열 리터럴:** `let s = "Hello"`에서 문자열 리터럴은 바이너리 내에 저장된 수정 불가능한 데이터이다. 변수 `s`는 이 바이너리의 특정 지점을 가리키는 슬라이스(`&str` 타입)이며, 이미 만들어진 데이터를 잠시 빌리는 것이다.

### (3) 슬라이스 사용의 장점
- **성능:** 데이터를 복사하지 않기 때문에 메모리 사용량이 거의 늘어나지 않는다.
- **안전성:** 대여 검사기가 감시하므로 슬라이스가 살아있는 동안에는 원본 데이터의 수정 및 삭제가 불가능하여 동기화가 보장된다.
- **유연성:** 매개변수 타입을 `&str`로 지정하면 `String`, 문자열 리터럴, 슬라이스 모든 타입을 인자로 받을 수 있다.

---

## 2. 🍳 조리 과정 (Code & Analysis)

```rust
fn first_word(s: &String) -> usize {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return i;
        }
    }

    s.len()
}

fn main() {
    let mut s = String::from("hello world");

    // word는 값 5를 가지게 된다.
    let word = first_word(&s);

    // 원본 문자열을 비운다.
    s.clear();

    // 여기서 word(5)는 여전히 유효하지만, s는 비어있으므로 논리적 불일치가 발생한다.
}
```

### 🔍 코드 분석
- **문제점:** 위 코드는 작동은 하지만, `word`가 첫 단어의 길이인 `5`라는 값을 갖고 있더라도 원본 문자열 `s`가 수정되면(`s.clear()`) 그 값은 의미 없는 값이 되어버린다.
- **버그 유발:** `word` 값은 원본 문자열의 데이터 변경을 반영하지 못한 값이기 때문에, 이를 원본의 수정 여부와 관계없이 사용하면 버그를 유발할 수 있다.

---

## 3. 🧂 깊은 맛 (Deep Dive)

### `&str` (타입) vs `&String[..]` (표현식)
- **의문점:** 문자열 슬라이스는 왜 `&str`로 표현하고 `&String[..]`으로 쓰지 않는 것일까?
- **결론:** `&str`은 타입의 이름이고, `&String[..]`는 표현식이다.
    - **`&str`:** "문자열 슬라이스"란 타입의 공식 명칭으로, 메모리 어딘가에 있는 `[포인터 + 길이]` 구조를 의미한다. 함수를 정의할 때는 이 자리에 어떤 타입의 데이터가 들어올 것인지를 명시해야 하므로 이 이름을 사용한다.
    - **`&String[..]`:** `String` 타입인 변수에서 슬라이스를 추출하는 "동작(표현식)"이다. 이 동작의 결과로 나오는 데이터의 타입이 `&str`인 것이다.

### 매개변수로서의 활용
- `fn first_word(s: &str) -> &str` 형태로 선언하면 "암묵적 역참조 강제 변환" 덕분에 문자열 참조, 리터럴, 슬라이스 모든 것을 인자로 받아오는 것이 가능하다.

---

## 4. 🔥 실패와 해결 (Troubleshooting)
> **공부하면서 만난 컴파일 에러나 오해했던 부분을 기록합니다.** (이게 진짜 자산입니다!)

### ❌ Error Scenario (Logical Bug)
- **상황:** 슬라이스를 사용하지 않고 인덱스(`usize`)만 저장했을 때, 원본 데이터가 변경되어 인덱스가 유효하지 않게 되는 논리적 오류 상황.

### ✅ 해결 방법 (Solution)
- **해결:** 문자열 슬라이스(`&str`)를 반환하도록 수정한다.
- **원리:** 슬라이스는 원본 데이터를 대여(Borrow)하는 것이므로, 컴파일러(대여 검사기)는 슬라이스가 사용되는 동안 원본 데이터(`String`)의 불변성을 강제한다. 즉, 슬라이스가 살아있는 동안에는 원본 데이터의 수정 및 삭제가 불가능해져 안전성이 보장된다.

---

## 5. 😋 시식평 (Tasting Note)

- **난이도:** ⭐⭐⭐☆☆
- **한줄평:** 원래 C를 주로 하던 나는 문자열을 배열로 인식하고 인덱싱으로 각 요소에 접근했었는데, 그런 개념과 다른 느낌이라 조금 어렵고 생소했다.
